// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Currency {
  USD
  EUR
  UAH
  RUB
  IRR
}

enum DeliveryType {
  AUTO_KEY
  MANUAL
}

enum ProductStatus {
  draft
  active
  inactive
}

enum Region {
  EU
  US
  TR
  GLOBAL
}

enum OfferStatus {
  draft
  active
  inactive
}

enum UserRole {
  BUYER
  SELLER
  ADMIN
}

model User {
  id              String    @id @default(uuid())
  email           String    @unique
  passwordHash    String?   @map("password_hash")
  name            String?
  role            UserRole  @default(SELLER)
  googleSub       String?   @unique @map("google_sub")
  emailVerifiedAt DateTime? @map("email_verified_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @default(now()) @map("updated_at")

  sellerTeamMemberships   SellerTeamMember[]
  sellerPresences         SellerPresence[]
  assignedOrders          Order[]            @relation("OrderAssignee")
  refreshTokens           RefreshToken[]
  sellerProfile           SellerProfile?
  authCodes               AuthCode[]
  emailVerificationTokens EmailVerificationToken[]

  @@map("users")
}

model EmailVerificationToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  tokenHash String    @unique @map("token_hash")
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@map("email_verification_tokens")
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  tokenHash String    @map("token_hash")
  revokedAt DateTime? @map("revoked_at")
  createdAt DateTime  @default(now()) @map("created_at")
  expiresAt DateTime  @map("expires_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@map("refresh_tokens")
}

enum SupportResponseTime {
  UNDER_15_MIN
  UNDER_1_HOUR
  UNDER_24_HOURS
}

model SellerProfile {
  id                  String               @id @default(uuid())
  userId              String               @unique @map("user_id")
  slug                String               @unique // Immutable store URL slug (derived from initial displayName)
  displayName         String               @map("display_name")
  logoUrl             String?              @map("logo_url")
  bio                 String?              @db.Text
  supportResponseTime SupportResponseTime? @map("support_response_time")
  timezone            String?              // IANA timezone (e.g., "Europe/Istanbul")
  languages           String[]             @default([]) // ISO language codes (e.g., ["en", "fa", "ru"])
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")

  user               User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  members            SellerTeamMember[]
  invites            SellerInvite[]
  presences          SellerPresence[]
  gatewayPreferences SellerGatewayPreference[]

  @@index([slug])
  @@map("seller_profiles")
}

model AuthCode {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  codeHash  String    @unique @map("code_hash")
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([codeHash])
  @@map("auth_codes")
}

enum SellerTeamRole {
  OWNER
  ADMIN
  OPS
  CATALOG
  SUPPORT
}

enum MemberStatus {
  ACTIVE
  SUSPENDED
}

// Seller team membership â€” RBAC pivot table
// Access is always scoped to (user_id + seller_id).
// Role is fixed (no custom roles); permissions derived from role.
model SellerTeamMember {
  id        String          @id @default(uuid())
  sellerId  String          @map("seller_id")
  userId    String          @map("user_id")
  role      SellerTeamRole  @default(SUPPORT)
  status    MemberStatus    @default(ACTIVE)
  createdAt DateTime        @default(now()) @map("created_at")
  updatedAt DateTime        @updatedAt @map("updated_at")

  seller SellerProfile @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sellerId, userId])
  @@index([sellerId, status])
  @@index([userId])
  @@map("seller_team_members")
}

// Seller presence tracking (online/away/offline)
model SellerPresence {
  sellerId     String   @map("seller_id")
  userId       String   @map("user_id")
  lastSeenAt   DateTime @map("last_seen_at")
  lastActiveAt DateTime? @map("last_active_at")

  seller SellerProfile @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([sellerId, userId])
  @@index([sellerId])
  @@map("seller_presence")
}

// Pending team invitations
model SellerInvite {
  id         String         @id @default(uuid())
  sellerId   String         @map("seller_id")
  email      String
  role       SellerTeamRole
  tokenHash  String         @unique @map("token_hash")
  expiresAt  DateTime       @map("expires_at")
  acceptedAt DateTime?      @map("accepted_at")
  createdAt  DateTime       @default(now()) @map("created_at")

  seller SellerProfile @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@unique([sellerId, email])
  @@index([tokenHash])
  @@map("seller_invites")
}

model Category {
  id        String     @id @default(uuid())
  parentId  String?    @map("parent_id")
  name      String
  slug      String
  isActive  Boolean    @default(true) @map("is_active")
  sortOrder Int        @default(0) @map("sort_order")
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  // Self-reference for parent-child relationship
  parent   Category?        @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Category[]       @relation("CategoryHierarchy")
  catalogProducts CatalogProduct[]

  // Constraints
  @@unique([slug, parentId], name: "unique_slug_per_level")
  @@index([parentId])
  @@index([isActive])
  @@index([sortOrder])
  @@index([isActive, parentId])
  @@map("categories")
}

// Marketplace catalog: Admin-managed product pages
model CatalogProduct {
  id          String   @id @default(uuid())
  categoryId  String   @map("category_id") // Must be child category
  name        String
  slug        String
  description String?  @db.Text
  imageUrl    String?  @map("image_url")
  isActive    Boolean  @default(true) @map("is_active")
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  category Category           @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  variants CatalogVariant[]

  @@unique([categoryId, slug])
  @@index([categoryId, isActive])
  @@index([isActive])
  @@map("catalog_products")
}

// Variants: region/duration/edition combinations
model CatalogVariant {
  id                    String   @id @default(uuid())
  productId             String   @map("product_id")
  region                Region
  durationDays          Int?     @map("duration_days")
  edition               String?  // e.g., "Standard", "Deluxe", etc.
  sku                   String   @unique
  supportsAutoKey       Boolean  @default(false) @map("supports_auto_key") // Can be delivered via automated key
  supportsManual        Boolean  @default(true) @map("supports_manual")    // Can be delivered manually
  requirementTemplateId String?  @map("requirement_template_id") // Admin-assigned buyer requirements template
  isActive              Boolean  @default(true) @map("is_active")
  sortOrder             Int      @default(0) @map("sort_order")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  product             CatalogProduct       @relation(fields: [productId], references: [id], onDelete: Cascade)
  offers              Offer[]
  requirementTemplate RequirementTemplate? @relation("VariantRequirements", fields: [requirementTemplateId], references: [id], onDelete: SetNull)

  @@unique([productId, region, durationDays, edition])
  @@index([productId, isActive])
  @@index([isActive])
  @@index([requirementTemplateId])
  @@map("catalog_variants")
}

// Seller listings for catalog variants
model Offer {
  id                       String       @id @default(uuid())
  sellerId                 String       @map("seller_id") // Future: FK to User
  variantId                String       @map("variant_id")
  status                   OfferStatus  @default(draft)
  deliveryType             DeliveryType @map("delivery_type")
  priceAmount              Int          @map("price_amount") // In smallest currency unit (cents)
  currency                 Currency
  stockCount               Int?         @map("stock_count") // For MANUAL delivery only; AUTO_KEY uses key pool count
  descriptionMarkdown      String?      @map("description_markdown") @db.Text // Seller-rich description (bold, lists, emojis)
  deliveryInstructions     String?      @map("delivery_instructions") @db.Text // Required for MANUAL to publish
  estimatedDeliveryMinutes Int?         @map("estimated_delivery_minutes") // SLA for MANUAL delivery (required to publish)
  publishedAt              DateTime?    @map("published_at")
  createdAt                DateTime     @default(now()) @map("created_at")
  updatedAt                DateTime     @updatedAt @map("updated_at")

  variant CatalogVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  keyPool KeyPool?       // 1:1 for AUTO_KEY offers
  orders  Order[]

  @@index([sellerId, status])
  @@index([variantId])
  @@index([variantId, status])
  @@index([status, publishedAt])
  @@map("offers")
}

// Legacy Product model removed - use Offer model instead
// All delivery configuration lives on the Offer model
// CatalogVariant defines which delivery types are SUPPORTED
// Offer defines the ACTUAL delivery type and configuration chosen by the seller

// ============================================
// AUTO-KEY DELIVERY SYSTEM
// ============================================

enum KeyStatus {
  AVAILABLE
  RESERVED
  DELIVERED
  INVALID
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  FULFILLED
  CANCELLED
  EXPIRED
}

enum WorkState {
  UNASSIGNED
  IN_PROGRESS
  DONE
}

// Key Pool - Container for keys belonging to an Offer
// Design decision: KeyPool belongs to Offer (1:1 relationship)
// This is simpler and ensures sellers cannot accidentally share keys across offers
model KeyPool {
  id        String   @id @default(uuid())
  offerId   String   @unique @map("offer_id")
  sellerId  String   @map("seller_id") // Denormalized for faster auth checks
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  offer Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)
  keys  Key[]

  @@index([sellerId])
  @@index([offerId, isActive])
  @@map("key_pools")
}

// Key - Individual key/code in a pool
// Security: code is encrypted at rest, codeHash for deduplication without revealing code
model Key {
  id            String    @id @default(uuid())
  poolId        String    @map("pool_id")
  codeEncrypted String    @map("code_encrypted") @db.Text // AES-256-GCM encrypted
  codeHash      String    @unique @map("code_hash") // SHA-256 hash for deduplication
  status        KeyStatus @default(AVAILABLE)
  reservedAt    DateTime? @map("reserved_at")
  deliveredAt   DateTime? @map("delivered_at")
  orderId       String?   @map("order_id") // Ties delivery to specific order
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  pool      KeyPool       @relation(fields: [poolId], references: [id], onDelete: Cascade)
  order     Order?        @relation(fields: [orderId], references: [id], onDelete: SetNull)
  auditLogs KeyAuditLog[]

  @@index([poolId, status]) // Fast lookup of available keys
  @@index([poolId, status, createdAt]) // For paginated listing with filters
  @@index([orderId])
  @@map("keys")
}

// ============================================
// KEY AUDIT LOG - Tracks key management actions
// ============================================

enum KeyAuditAction {
  UPLOAD
  EDIT
  INVALIDATE
  REVEAL
}

// Audit log for key management actions
model KeyAuditLog {
  id        String         @id @default(uuid())
  keyId     String         @map("key_id")
  poolId    String         @map("pool_id")
  sellerId  String         @map("seller_id")
  action    KeyAuditAction
  metadata  Json?          // Additional context (e.g., old hash for EDIT)
  createdAt DateTime       @default(now()) @map("created_at")

  key Key @relation(fields: [keyId], references: [id], onDelete: Cascade)

  @@index([keyId])
  @@index([poolId, createdAt])
  @@index([sellerId, createdAt])
  @@map("key_audit_logs")
}

// Order - Full order lifecycle with admin assignment
model Order {
  id                            String           @id @default(uuid())
  displayCode                   String           @unique @map("display_code") // Public order identifier (e.g., "ORD_A1B2C3D4E5")
  buyerId                       String           @map("buyer_id") // Future: FK to User
  sellerId                      String           @map("seller_id") // Denormalized for faster queries
  offerId                       String           @map("offer_id")
  status                        OrderStatus      @default(PENDING_PAYMENT)
  
  // Price snapshots (captured at order creation)
  basePriceAmount               Int              @map("base_price_amount") // Seller's base price (cents)
  platformFeeBpsSnapshot        Int              @map("platform_fee_bps_snapshot") // Platform fee basis points at time of order
  feeAmount                     Int              @map("fee_amount") // Calculated platform fee (cents)
  buyerTotalAmount              Int              @map("buyer_total_amount") // Total buyer pays (base + fee, cents)
  currency                      Currency
  
  // Fulfillment data
  deliveredKey                  String?          @map("delivered_key") @db.Text // Decrypted key stored on fulfillment (for buyer retrieval)
  
  // Buyer requirements
  requirementsPayload           Json?            @map("requirements_payload") // Buyer-provided data matching template fields (non-sensitive)
  requirementsPayloadEncrypted  String?          @map("requirements_payload_encrypted") @db.Text // Encrypted sensitive buyer data (account credentials, etc.)
  
  // Seller team assignment (internal workflow, NOT a status)
  assignedToUserId              String?          @map("assigned_to_user_id") // Seller team member assigned
  assignedAt                    DateTime?        @map("assigned_at")
  workState                     WorkState?       @map("work_state") // UNASSIGNED | IN_PROGRESS | DONE
  
  // Lifecycle timestamps
  paidAt                        DateTime?        @map("paid_at")
  fulfilledAt                   DateTime?        @map("fulfilled_at")
  cancelledAt                   DateTime?        @map("cancelled_at")
  createdAt                     DateTime         @default(now()) @map("created_at")
  updatedAt                     DateTime         @updatedAt @map("updated_at")

  offer        Offer  @relation(fields: [offerId], references: [id], onDelete: Restrict)
  keys         Key[]  // One key per order for AUTO_KEY delivery
  assignedTo   User?  @relation("OrderAssignee", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  @@index([buyerId, status])
  @@index([offerId])
  @@index([sellerId, status])
  @@index([status])
  @@index([status, paidAt])
  @@index([assignedToUserId])
  @@index([sellerId, workState])
  @@map("orders")
}

// ============================================
// BUYER REQUIREMENTS SYSTEM
// ============================================

enum RequirementFieldType {
  TEXT
  EMAIL
  NUMBER
  SELECT
  TEXTAREA
  ACCOUNT_CREDENTIALS // Special type for username/password pairs (always sensitive)
}

// Admin-managed templates for buyer requirements (e.g., "Account info for Netflix", "Character name for WoW")
model RequirementTemplate {
  id          String   @id @default(uuid())
  name        String   // e.g., "Netflix Account Delivery", "WoW Character Boost"
  description String?  @db.Text
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  fields   RequirementField[]
  variants CatalogVariant[]   @relation("VariantRequirements")

  @@map("requirement_templates")
}

// Individual fields within a requirement template
model RequirementField {
  id          String               @id @default(uuid())
  templateId  String               @map("template_id")
  key         String               // programmatic key, e.g., "email", "password", "character_name"
  label       String               // UI label, e.g., "Netflix Email", "Account Password"
  type        RequirementFieldType @default(TEXT)
  required    Boolean              @default(true)
  helpText    String?              @map("help_text") // Helper text for buyers
  placeholder String?              // Input placeholder
  options     Json?                // For SELECT type: ["Option 1", "Option 2"]
  validation  Json?                // Validation rules: { minLength: 3, maxLength: 100, pattern: "regex" }
  sensitive   Boolean              @default(false) // If true, value is encrypted at rest and masked in UI
  sortOrder   Int                  @default(0) @map("sort_order")
  createdAt   DateTime             @default(now()) @map("created_at")
  updatedAt   DateTime             @updatedAt @map("updated_at")

  template RequirementTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([templateId, key])
  @@index([templateId, sortOrder])
  @@map("requirement_fields")
}

// ============================================
// PLATFORM SETTINGS
// ============================================

// Platform-wide configurable settings (single-row table)
// Enforced as single-row via service logic and seed
model PlatformSettings {
  id             String   @id @default(uuid())
  platformFeeBps Int      @map("platform_fee_bps") // Basis points (300 = 3.00%)
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@map("platform_settings")
}

// ============================================
// PLATFORM GATEWAYS (Payment Providers)
// ============================================

enum SettlementMode {
  PLATFORM_COLLECT // Platform collects payment, settles to seller
  SELLER_DIRECT    // Future: seller collects directly
}

// Admin-managed platform payment gateways
model PlatformGateway {
  id                       String         @id @default(uuid())
  name                     String         // Display name (e.g. "Zibal Checkout")
  provider                 String         // Provider key (e.g. "zibal", "zarinpal")
  settlementMode           SettlementMode @default(PLATFORM_COLLECT) @map("settlement_mode")
  feePercent               Decimal?       @map("fee_percent") @db.Decimal(5, 2) // Optional metadata; no pricing changes
  supportedCurrencies      String[]       @default([]) @map("supported_currencies") // e.g. ["IRR", "USD"]
  isEnabledGlobally        Boolean        @default(true) @map("is_enabled_globally") // Admin kill switch
  sellerCanToggle          Boolean        @default(true) @map("seller_can_toggle") // false = admin locked
  defaultEnabledForNewSellers Boolean     @default(true) @map("default_enabled_for_new_sellers")
  sortOrder                Int            @default(0) @map("sort_order")
  createdAt                DateTime       @default(now()) @map("created_at")
  updatedAt                DateTime       @updatedAt @map("updated_at")

  sellerPreferences SellerGatewayPreference[]

  @@index([isEnabledGlobally, sortOrder])
  @@map("platform_gateways")
}

// Seller-specific gateway preferences (enable/disable)
model SellerGatewayPreference {
  id        String   @id @default(uuid())
  sellerId  String   @map("seller_id")
  gatewayId String   @map("gateway_id")
  isEnabled Boolean  @default(true) @map("is_enabled")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  seller  SellerProfile   @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  gateway PlatformGateway @relation(fields: [gatewayId], references: [id], onDelete: Cascade)

  @@unique([sellerId, gatewayId])
  @@index([sellerId])
  @@index([gatewayId])
  @@map("seller_gateway_preferences")
}
